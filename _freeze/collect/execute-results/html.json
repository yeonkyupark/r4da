{
  "hash": "38c5500cd3a9d5276ac6c30b671e744e",
  "result": {
    "engine": "knitr",
    "markdown": "# 자료수집 {#sec-collect}\n\n문제 정의에 따라 데이터를 수집한다. 현장에서는 다양한 형태, 즉 개인이 텍스트 파일로 관리할 수도 있고, 엑셀 등과 같은 특정 프로그램을 사용하여 관리할 수도, 또는 관계형 데이터베이스를 이용하여 데이터를 축적할 수도 있다. 뿐만 아니라 표준화나 정규화가 잘 적용된 정형 데이터 일수도 있고 이메일이나 녹음, 녹화 파일 등 비정형 데이터일 수도 있다.\n\n## 직접 생성\n\n데이터 양이 많지 않다면 단순히 데이터를 복사/붙여넣기 하거나 하나씩 직접 작성할 수도 있다.\n\n### data.frame을 이용한 자료 생성성\n\nOA제품별 가격을 data.frame을 통해 작성할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_OA <- data.frame(\n  product = c(\"PC\", \"Notebook\", \"Monior\"),\n  price = c(1000000, 1500000, 500000)\n)\ndf_OA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   product   price\n1       PC 1000000\n2 Notebook 1500000\n3   Monior  500000\n```\n\n\n:::\n:::\n\n\n### tibble을 이용한 자료 생성\n\ndata.frame에서 개선된 자료형인 tibble 형식을 이용할 수도 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tibble)\ntb_OA <- tibble(\n  product = c(\"PC\", \"Notebook\", \"Monior\"),\n  price = c(1000000, 1500000, 500000)\n)\ntb_OA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  product    price\n  <chr>      <dbl>\n1 PC       1000000\n2 Notebook 1500000\n3 Monior    500000\n```\n\n\n:::\n:::\n\n\n### package를 이용한 자료 입력\n\n`datapasta`[^collect-1]패키지를 이용하여 자료를 쉽게 입력할 수 있다. `datapasta`를 설치하게 되면 `Addins` 메뉴에 추가된다.\n\n[^collect-1]: <https://cran.r-project.org/web/packages/datapasta/readme/README.html>\n\n![](https://raw.githubusercontent.com/milesmcbain/datapasta/master/inst/media/tribble_paste.gif)\n\n스프레드쉬트에서 아래와 같이 입력한 후 복사를 한다.\n\n![](images/clipboard-1868840731.png)\n\n`Addins` 메뉴를 통해 원하는 명령어를 선택한다.\n\n![](images/clipboard-2793799454.png)\n\n아래는 `Paste as tribble` 명령어를 선택한 결과이다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble::tribble(\n        ~product,   ~price,\n            \"PC\", 1000000L,\n        \"NotePC\", 1500000L,\n       \"Monitor\",  500000L\n       )\n```\n:::\n\n\n### 데이터 내보내기\n\n작성된 데이터는 여러 형태로 내보낼 수 있다. 하지만 다른 프로그램과 호환성이나 범용성을 고려한다면 가능한 `.csv` 형식으로 저장한다. 대표적으로 `utils` 패키지 내 `write.csv()`와 `readr` 패키지 내 `write_csv()`를 이용한다. 사용법은 대동소이하며 개인 취향에 따라 취사선택하면 된다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite.csv(x = df_OA, file = \"./OA.csv\")\n```\n:::\n\n\n이외 엑셀 형태로 저장할 수도 있다. `opnexlsx` 패키지를 설치하여 읽고(`read.xlsx()`) 필요에 따라 적절히 활용한다.\n\n## 파일에서 읽어 오기\n\n데이터 분석에 사용되는 파일 형식은 통상적으로 `.csv` 형식을 이용한다. 여러 함수를 통해 파일 내 데이터를 읽을 수 있지만 통상적으로 `read.csv()`을 이용한다. 테이블 형태로 구성된 데이터라 하더라도 구분자나 해더 여부, 행 이름 등 파일 특성에 따라 `read.table()`이나 `read.delim()`을 이용하기도 한다.\n\n### csv 파일에서 읽어 오기\n\n`read.csv`를 통해 파일을 읽어 올 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_OA_from_csv <- read.csv(file = \"./OA.csv\")\ndf_OA_from_csv\n```\n:::\n\n\n### 엑셀 파일에서 읽어 오기\n\n`openxlsx` 패키지 내 `write.xlsx()`를 이용하여 엑셀 형식으로 저장할 수 있다.\n\n### 대용량 파일 읽어 오기\n\n`data.table` 패키지 내 `fread()` 함수를 통해 대용량 데이터를 빠르고 편리하게 읽을 수 있다. `data.frame`이나 `tibble` 형태의 자료형은 다양한 패키지를 사용하여 데이터 정제, 가공, 집약할 수 있으나 처리 속도가 느리다는 단점이 있다. 이를 해결하기 위한 데이터 형태가 `data.table`이다. 즉 `fread()`를 통해 데이터를 읽게 되면 자료형태는 `data.table`이 된다. `data.frame` 속성을 가지고 있어 `data.frame`을 지원하는 패키지를 대부분 사용할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt_OA_from_csv <-data.table::fread(\"./OA.csv\")\ndt_OA_from_csv\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      V1  product   price\n   <int>   <char>   <num>\n1:     1       PC 1000000\n2:     2 Notebook 1500000\n3:     3   Monior  500000\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(dt_OA_from_csv)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.table\" \"data.frame\"\n```\n\n\n:::\n:::\n\n\n## DB 또는 외부에서 읽어 오기\n\n이 외 데이터가 자동으로 수집되어 적재되는 시스템에서 읽어 올 수 있다. 이런 경우 데이터베이스(DB)로 저장소가 구축되어 있고 DBMS를 통해 관리된다. R에서는 `sql`을 지원하며 제품별 패키지가 제공되어 있다. 본 예제에서는 `SQLite`에서 데이터를 읽고 쓰는 방법을 알아 보기로 한다.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}